import json

with open("./met2.json", "r") as file:
    met2 = json.load(file)
    
areas = met2["areas"]
rooms = met2["rooms"]
    
def out(*vargs):
    print(*vargs)
    
MARGIN = 1
    
out(
"""// auto-generated by pd2c.py
#define TILE_EMPTY 1
#define TILE_NORMAL 2
#define TILE_HPIPE 3
#define TILE_VPIPE 4
#define TILE_REPLACEMENTS 5
#define TILE_DOOR_NORTH 5
#define TILE_DOOR_WEST 6
#define TILE_DOOR_EAST 7
#define TILE_DOOR_SOUTH 8
#define TILE_EXIT_NORTH 9
#define TILE_EXIT_WEST 10
#define TILE_EXIT_SOUTH 11
#define TILE_EXIT_EAST 12
#define TILE_SHUNT 13
#define TILE_BEAM 14


#define TILE_HJUMP 17
#define TILE_ITEM 18
#define TILE_SAVE 19
#define TILE_RECHARGE_ENERGY 20
#define TILE_RECHARGE_MISSILE 21
#define TILE_RECHARGE_BOTH 22
#define TILE_METROID_ALPHA 23
#define TILE_METROID_GAMMA 24
#define TILE_METROID_ZETA 25
#define TILE_METROID_OMEGA 26
#define TILE_METROID_LARVA 27
#define TILE_METROID_QUEEN 28
#define TILE_UNKNOWN 29
#define TILE_SHIP_LEFT 30
#define TILE_SHIP_RIGHT 31

#pragma pack(push, 1)
struct SpecialTile {
    uint8_t area_x : 5;
    uint8_t area_y : 5;
    bool masking : 1;
    uint8_t type : 5;
    uint8_t object_slot : 7;
    uint8_t dark : 1;
    uint8_t embedding : 2;
    uint8_t bank : 4;
    uint8_t ridx; // or 255 if not associated with a room
};

struct Area {
    const char* name;
    uint8_t w : 5;
    uint8_t h : 5;
    uint8_t special_tile_c;
    struct SpecialTile* special_tiles;
};

struct Room {
    uint8_t area : 4;
    uint8_t area_x : 5;
    uint8_t area_y : 5;
    uint8_t w : 4;
    uint8_t h : 4;
    uint8_t embeddings : 2;
    uint32_t data_offset : 26;
};
#pragma pack(pop)
"""
)

special_tile_types = [
    # always shown, so arrange back-to-front
    "tiles",
    "doors",
    
    # masks what's after it, so arrange front-to-back
    "alphas",
    "metroids", #(except alphas)
    "items",
    "fixtures",
]

out_rooms = "";
out_areas = "";
out_special_tiles = [{special_tile_type: "" for special_tile_type in special_tile_types} for i, area in enumerate(areas)]

class BitStream:
    def __init__(self):
        self._bits = []
        self._bit_offset = 0

    def append_value(self, value, bit_count):
        """Append an integer as bit_count bits (MSB first)."""
        if value >= (1 << bit_count):
            raise ValueError(f"Value {value} does not fit in {bit_count} bits")
        for i in reversed(range(bit_count)):
            self._bits.append((value >> i) & 1)
        self._bit_offset = len(self._bits)

    def bit_offset(self):
        return self._bit_offset

    def to_bytes(self):
        result = []
        cur = 0
        for i, bit in enumerate(self._bits):
            cur = (cur << 1) | bit
            if (i + 1) % 8 == 0:
                result.append(cur)
                cur = 0
        if len(self._bits) % 8 != 0:
            cur <<= (8 - (len(self._bits) % 8))
            result.append(cur)
        return result

    def __iter__(self):
        for b in self.to_bytes():
            yield b

bs = BitStream()

ridx2area = {}
for i, area in enumerate(met2["areas"]):
    area["x0"] -= MARGIN
    area["y0"] -= MARGIN
    area["x1"] += MARGIN
    area["y1"] += MARGIN
    
    for ridx in area["rooms"]:
        ridx2area[ridx] = i
    out_areas += "{\n"
    out_areas += f"   .name = \"{area['name']}\",\n"
    out_areas += f"   .w = {area['x1'] - area['x0']},\n"
    out_areas += f"   .h = {area['y1'] - area['y0']},\n"
    out_areas += f"  .special_tile_c = sizeof(area_{i}_special_tiles)/sizeof(struct SpecialTile),\n"
    out_areas += f"  .special_tiles = area_{i}_special_tiles,\n"
    out_areas += "},\n"
        
tile_types_to_name = {
    -1: "TILE_EMPTY",
    2: "TILE_HPIPE",
    3: "TILE_VPIPE",
    4: "DARK",
}

BIT_EAST = 1
BIT_WEST = 2
BIT_NORTH = 4
BIT_SOUTH = 8

door_dirs_to_name = {
    BIT_EAST: "TILE_DOOR_EAST",
    BIT_WEST: "TILE_DOOR_WEST",
    BIT_NORTH: "TILE_DOOR_NORTH",
    BIT_SOUTH: "TILE_DOOR_SOUTH",
}

door_dirs_to_exit_name = {
    BIT_EAST: "TILE_EXIT_EAST",
    BIT_WEST: "TILE_EXIT_WEST",
    BIT_NORTH: "TILE_EXIT_NORTH",
    BIT_SOUTH: "TILE_EXIT_SOUTH",
}

feature_name_to_tile_name = {
    "plasma": ("fixtures", "TILE_BEAM"),
    "ice": ("fixtures", "TILE_BEAM"),
    "spazer": ("fixtures", "TILE_BEAM"),
    "wave": ("fixtures", "TILE_BEAM"),
    "varia": ("items", "TILE_ITEM"),
    "high-jump": ("items", "TILE_ITEM"),
    "screw-attack": ("items", "TILE_ITEM"),
    "space-jump": ("items", "TILE_ITEM"),
    "spider": ("items", "TILE_ITEM"),
    "spring-ball": ("items", "TILE_ITEM"),
    "energy-tank": ("items", "TILE_ITEM"),
    "missile-tank": ("items", "TILE_ITEM"),
    "bombs": ("items", "TILE_ITEM"),
    "save": ("fixtures", "TILE_SAVE"),
    "missile-recharge": ("fixtures", "TILE_RECHARGE_ENERGY"),
    "energy-recharge": ("fixtures", "TILE_RECHARGE_ENERGY"),
    "missile-recharge": ("fixtures", "TILE_RECHARGE_MISSILE"),
    "alpha": ("alphas", "TILE_METROID_ALPHA"),
    "gamma": ("metroids", "TILE_METROID_GAMMA"),
    "zeta": ("metroids", "TILE_METROID_ZETA"),
    "omega": ("metroids", "TILE_METROID_OMEGA"),
    "larva": ("metroids", "TILE_METROID_LARVA"),
    "queen": ("metroids", "TILE_METROID_QUEEN"),
    "egg": ("metroids", "TILE_UNKNOWN"),
}

bit_direction = {
    BIT_EAST: (1, 0),
    BIT_WEST: (-1, 0),
    BIT_NORTH: (0, -1),
    BIT_SOUTH: (0, 1),
}

def add_special_tile(area_idx, _ridx, category, name, x, y, object_slot=None, object_embedding=None, object_bank=None):
    dark = 0;
    if _ridx is None:
        _ridx = 255
    if name == "DARK":
        dark = 1
        name = "TILE_NORMAL"
    out_special_tiles[area_idx][category] += "{" + \
f""".area_x = {x},
.area_y = {y}, 
.masking = {0 if category in 'tiles' or category in 'doors' else 1},
.type = {name},
.object_slot = 0x{0 if object_slot is None else object_slot:02x},
.dark = {dark},
.embedding = {0 if object_embedding is None else object_embedding},
.bank = {0 if object_bank is None else object_bank},
.ridx = {_ridx},
""" + "},\n"
        
for ridx, room in enumerate(met2["rooms"]):
    area_idx = ridx2area[ridx]
    area = areas[area_idx]
    x = room["x"] - area["x0"]
    y = room["y"] - area["y0"]
    out_rooms += "{\n"
    out_rooms += f"  .area = {area_idx},\n"
    out_rooms += f"  .area_x = {x},\n"
    out_rooms += f"  .area_y = {y},\n"
    out_rooms += f"  .w = {room['w'] % 16},\n"
    out_rooms += f"  .h = {room['h'] % 16},\n"
    embeddingbits = room['w'] * room['h']
    out_rooms += f"  .embeddings = {len(room['states'])},\n"
    out_rooms += f"  .data_offset = 0x{bs.bit_offset():X},\n"
    for state in room['states']:
        bs.append_value(state['bank'] - 9, 3)
        em_x = state['x']
        em_y = state['y']
        if em_x < 0: em_x += 32
        if em_x < 0: em_x += 32
        bs.append_value(em_x, 5)
        bs.append_value(em_y, 5)
        for yoff, row in enumerate(state["cells"]):
            for xoff, cell in enumerate(row):
                if cell:
                    bs.append_value(1, 1)
                else:
                    bs.append_value(0, 1)
        
        for yoff, row in enumerate(room["cells"]):
            for xoff, cell in enumerate(row):
                if cell != 0 and cell != 1:
                    add_special_tile(area_idx, ridx, "tiles", tile_types_to_name[cell], x + xoff, y + yoff)
        
        for door in room["doors"]:
            if door["exit_states"] != 0:
                door_x = door["x"] + x
                door_y = door["y"] + y
                add_special_tile(area_idx, ridx, "doors", door_dirs_to_name[door["dir"]], door_x, door_y)
                xd, yd = bit_direction[door["dir"]]
                if "to-area" in door:
                    add_special_tile(area_idx, ridx, "tiles", door_dirs_to_exit_name[door["dir"]], door_x + xd, door_y + yd)
                if "jump" in door:
                    dx, dy = door["jump"]
                    if dy == 0 and dx != 0:
                        for i in range(min(door_x, door_x + dx)+1, max(door_x, door_x + dx)):
                            add_special_tile(area_idx, door_x, "tiles", "TILE_HJUMP", i, door_y)
                    elif dy == 1 and dx == -1:
                        add_special_tile(area_idx, 0, "doors", "TILE_SHUNT", door_x-1, door_y)
                        add_special_tile(area_idx, 1, "doors", "TILE_SHUNT", door_x, door_y)
                    elif dy == -1 and dx == 1:
                        add_special_tile(area_idx, 2, "doors", "TILE_SHUNT", door_x, door_y)
                        add_special_tile(area_idx, 3, "doors", "TILE_SHUNT", door_x+1, door_y)
                    else:
                        assert False, f"unable to render jump of displacement {(dx, dy)}"
                
            
        if "features" in room:
            recharges = dict()
            double_recharge_handled = set()
            for feature in room["features"]:
                name = feature["type"]
                xoff = feature["x"]
                yoff = feature["y"]
                if "recharge" in name:
                    if (xoff, yoff) in recharges:
                        recharges[(xoff, yoff)] += 1
                    else:
                        recharges[(xoff, yoff)] = 1
            for feature in room["features"]:
                is_double_recharge = False
                name = feature["type"]
                slot = feature["slot"] if "slot" in feature else None
                feature_em = feature["state"] if "state" in feature else None
                xoff = feature["x"]
                yoff = feature["y"]
                if "recharge" in name and (xoff, yoff) in recharges and recharges[(xoff, yoff)] >= 2:
                    if (xoff, yoff) in double_recharge_handled:
                        continue
                    double_recharge_handled.add((xoff, yoff))
                    is_double_recharge = True
                if is_double_recharge:
                    add_special_tile(area_idx, ridx, "fixtures", "TILE_RECHARGE_BOTH", x + xoff, y + yoff)
                elif name == "ship":
                    add_special_tile(area_idx, None, "fixtures", "TILE_SHIP_LEFT", x + xoff, y + yoff)
                    add_special_tile(area_idx, None, "fixtures", "TILE_SHIP_RIGHT", x + xoff + 1, y + yoff)
                elif name in feature_name_to_tile_name:
                    feature_category, feature_tile_name = feature_name_to_tile_name[name]
                    add_special_tile(area_idx, ridx, feature_category, feature_tile_name, x + xoff, y + yoff, slot, feature_em, room["states"][feature_em]["bank"] if feature_em is not None else 0)
                else:
                    assert False, f"unknown feature: {feature}"
    out_rooms += "},\n"
# output

for i, out_special_tiles_arr in enumerate(out_special_tiles):
    out(f"struct SpecialTile area_{i}_special_tiles[] = " + "{" + "".join(out_special_tiles_arr[special_tile_type] for special_tile_type in special_tile_types) + "};")

out("struct Area areas[] = {\n" + out_areas + "};")
out("struct Room rooms[] = {\n" + out_rooms + "};")
out("const uint8_t room_embeddings[] = {" + ",".join(f"0x{v:02x}" for v in bs.to_bytes()) + "};")